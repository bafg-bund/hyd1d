---
title: hyd1d
subtitle: Ein R-Paket zur Interpolation von 1D-Wasserspiegellagen und Pegeldaten
author: Arnd Weber, Marcus Hatz, Wolfgang Stürmer, Wilfried Wiechmann
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  revealjs::revealjs_presentation:
    theme: white
    css: ../presentation/presentation.css
    highlight: pygments
    self_contained: true
    center: true
    transition: fade
    fig_width: 9
    fig_height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, message = FALSE)
```

# Wie erhält man Wasserstandsinformationen für einen Punkt oder eine Strecke an einer Bundeswasserstraße? {#problemstellung}

## {#problemstellung-karte data-background="map.png" data-background-size="auto 800px"}

## 21.12.2016 {#problemstellung-karte-date data-background="map_flooded.png" data-background-size="auto 800px" data-transition="none" data-transition-speed="fast"}

# PEGELONLINE {#po}

## Abfrage der nächstgelegenen Pegel {#po-query}

- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=501490>
- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=502000>

## {#po-query-rosslau data-background="screenshot_pegelonline_Rosslau.png" data-background-size="auto 750px"}

## {#po-query-dessau data-background="screenshot_pegelonline_Dessau.png" data-background-size="auto 750px"}

## Wasserstand der angrenzenden Pegel {#po-res1}

```{r pegelonline-res1}
# standard library path for the installed local packages
R_version <- paste(sep = ".", R.Version()$major, R.Version()$minor)
lib <- paste0("~/R/", R_version, "/")
require(hyd1d, lib.loc = lib)
require(plotrix, lib.loc = lib)

cex_legend <- 0.7

xlim_min <- 257
xlim_max <- 263
ylim_min <- 53.8
ylim_max <- 55.8
wldf <- WaterLevelDataFrame(river = "Elbe",
                            time = as.POSIXct("2016-12-21"),
                            station = seq(257, 262, 0.1))
wldf1 <- waterLevel(wldf, TRUE)
gs <- getGaugingStations(wldf1)
id <- gs$km_qps >= xlim_min & gs$km_qps <= xlim_max
lm_pegelonline <- lm(wl ~ km_qps, data = gs[id, ])

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Lineare Interpolation? {#po-res2}

```{r pegelonline-res2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    #abline(lm_pegelonline, col = "darkblue")
    lines(x = gs$km_qps, y = gs$wl, col = "darkblue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

# FLYS 3

## Einleitung {#flys-intro}

> - **FLYS** ist kein hydraulisches Modell, sondern eine Plattform zur Ausgabe und Interpolation von Modellergebnissen.
> - **FLYS** stellt 30 stationäre Wasserspiegellagen von 0.5MNQ bis HQ500 aus 1D-SOBEK-Berechnungen bereit.
> - <https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html>

## Verfügbare Wasserspiegellagen {#flys-wsl}

```{r flys-wsl}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g", 
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75", 
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62), 
         xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
}
```

## Ausgewählte Wasserspiegellagen {#flys-wsl-sel1}

```{r flys-wsl-sel1}
mq_0.5 <- waterLevelFlys3(wldf, "0.5MQ")
a <- waterLevelFlys3(wldf, "a")
mq_0.75 <- waterLevelFlys3(wldf, "0.75MQ")
mq <- waterLevelFlys3(wldf, "MQ")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    lines(mq_0.5$station, mq_0.5$w, col = "darkblue")
    lines(a$station, a$w, col = "darkblue")
    lines(mq_0.75$station, mq_0.75$w, col = "darkblue")
    text(262, min(mq_0.5$w), "0.5MQ", pos = 4, cex = 1)
    text(262, min(a$w), "a", pos = 4, cex = 1)
    text(262, min(mq_0.75$w), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel2}

```{r flys-wsl-sel2}
wldf2 <- waterLevelFlys3InterpolateY(wldf, "WITTENBERG", shiny = TRUE)
wldf3 <- waterLevelFlys3InterpolateY(wldf, "ROSSLAU", shiny = TRUE)
wldf4 <- waterLevelFlys3InterpolateY(wldf, "DESSAU", shiny = TRUE)

{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    #text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel3}

```{r flys-wsl-sel3}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    #lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel4}

```{r flys-wsl-sel4}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel5}

```{r flys-wsl-sel5}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel6}

```{r flys-wsl-sel6}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # difference
    id_sel <- which(wldf1$station == 260)
    arrows(x0 = 260, y0 = wldf3$w[id_sel], y1 = wldf4$w[id_sel], length = 0.13, 
           code = 3, col = "red", lwd = 3)
    text(260, (wldf3$w[id_sel] + wldf4$w[id_sel])/2, 
         labels = paste(round(wldf4$w[id_sel] - wldf3$w[id_sel], 2), "m"), 
         pos = 4, col = "red", font = 2)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Zusammenfassung {#flys-summary}

> - **FLYS** interpoliert stationäre Wasserspiegellagen abschnittsweise mit 
jeweils einem Bezugspegel.
> - Die Auswahl des Bezugspegels hat starken Einfluss auf die resultierende 
Wasserspiegellage.
> - Durch instationäre Effekte sind Differenzen von mehreren Dezimetern 
zwischen mit **FLYS** berechneten Wasserspiegellagen realistisch.
> - Sprünge, bzw. Diskontinuitäten an Abschnittsgrenzen sind der Normalfall.

# hyd1d

## Einleitung {#hyd1d-intro}

> - **hyd1d** ist als **R**-Paket programmiert und soll über [CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht werden.
> - **hyd1d** integriert Paket-eigene Pegeldaten aus der
[HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html), 
aktuelle Pegeldaten von [PEGELONLINE](https://pegelonline.wsv.de), und 
Wasserspiegellagen von [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html).
> - Pegel- und Wasserspiegeldaten werden so miteinander interpoliert, dass 
resultierenden Wasserspiegellagen auch über lange Strecken keine 
Diskontinuitäten aufweisen.

## Methodik {#hyd1d-method}

1. Bestimmung der relevanten Pegel für den Berechnungsort, bzw. die
Berechnungsstrecke
2. Bestimmung der Wasserstände dieser Pegeln zum gewählten Zeitpunkt
3. Aufteilung der Berechnungsstrecke in Abschnitte, die von jeweils zwei Pegeln 
eingerahmt werden
4. Abschnittsweise Bestimmung, welche FLYS3-Wasserspiegellagen die 
Wasserspiegellagen an den beiden Pegeln einrahmen
5. Abschnittsweise, entfernungsabhängige Interpolation zwischen den einrahmenden
FLYS3-Wasserspiegellagen

## 1. Streckenrelevante Pegel {#hyd1d-method-1}

```{r hyd1d-method-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # berechnungsstrecke
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
}
```

## 2. Wasserstände {#hyd1d-method-2}

```{r hyd1d-method-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", box.col = "white")
    box()
}
```

## 3. Aufteilung der Berechnungsstrecke {#hyd1d-method-3}

```{r hyd1d-method-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # sections
    for (i in 1:(nrow(gs) - 1)) {
        rect(gs$km_qps[i], 53, gs$km_qps[i + 1], 54, col = "lightblue", border = NA)
        text((gs$km_qps[i] + gs$km_qps[i + 1])/2, 53.5, i, font = 2)
        lines(rep(gs$km_qps[i], 2), c(53, 54), lwd = 2)
        lines(rep(gs$km_qps[i + 1], 2), c(53, 54), lwd = 2)
    }
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", 
           box.col = "white")
    box()
}
```

## 4. Einrahmende Wasserspiegellagen {#hyd1d-method-4}

```{r hyd1d-method-4}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
              col = "darkblue")
    }
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i], col = "darkblue")
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "darkblue")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(a$w[i]), "a", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## 5.1 Gewichtung an den Pegeln {#hyd1d-method-5-1}

```{r hyd1d-method-5-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.52)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 4,
         font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 2,
         font = 2, col = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(257.8, max(mq_0.5$w[i]), "0", pos = 2, font = 2)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    text(257.8, max(mq_0.75$w[i]), "1", pos = 2, font = 2, col = "red")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA), 
           lty = c(0, 0, 1, 1), 
           legend = c("Wasserstand", "Gewicht", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.font = c(1, 2, 1, 1), 
           text.col = c(1, "darkblue", 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.2 Gewichtung entlang der Strecke {#hyd1d-method-5-2}

```{r hyd1d-method-5-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(-0.1, 1.1), xlab = "Flusskilometer (km)", 
         ylab = "relatives Gewicht")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], -0.05, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 1.05, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 1.05, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # weighting
    lines(x = c(gs$km_qps[id][1], gs$km_qps[id][2]),
          y = c(gs$weight_up[id][1], gs$weight_do[id][2]))
    points(gs$km_qps[id][1], gs$weight_up[id][1], pch = 21, col = 1, bg = 1)
    points(gs$km_qps[id][2], gs$weight_do[id][2], pch = 21, col = 1, bg = 1)
}
```

## 5.3 Interpolation der Wasserspiegellage {#hyd1d-method-5-3}

```{r hyd1d-method-5-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    lines(wldf1$station[i], wldf1$w[i], col = "darkblue", lwd = 2)
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 2,
         cex = 1, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 4,
         cex = 1, font = 2, col = "darkblue")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           text.font = c(1, 2, 1, 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.4 Interpolationen zusammengefasst {#hyd1d-method-5-4}

```{r hyd1d-method-5-4}
{
    par(cex = 1.2)
    plotShiny(wldf1, TRUE, TRUE, TRUE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmark
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 0.7, border = FALSE, col = "blue", 
                 srt = 90)
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           cex = cex_legend, bty = "n")
    box()
}
```

# Das R-Paket

## Installation {#package-install}

- Bisher ist **hyd1d** nur innerhalb der BfG verfügbar und kann mit folgenden 
Befehlen installiert werden:
```{r package-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_git("git://apps.bafg.de/gitbucket/webera/hyd1d.git")
```

- Nach einer Veröffentlichung auf [CRAN](https://cran.r-project.org) reicht eine 
Zeile zur Installation:
```{r package-install2, eval = FALSE, echo = TRUE}
install.packages("hyd1d")
```

- Vor der Verwendung muss es dann nur noch geladen werden:
```{r package-install3, eval = FALSE, echo = TRUE}
library("hyd1d")
```

## S4-Klasse WaterLevelDataFrame

## waterLevel...-Funktionen

# hydFlood3

# Produkte

## {#product-shiny-waterlevel data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/05-waterlevel/"}

## {#product-shiny-waterlevelpegelonline data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/06-waterlevelpegelonline/"}

## {#product-shiny-flut3 data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/03-flut3/"}

# Zusammenfassung

## hyd1d

## Flut3
