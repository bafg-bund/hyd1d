---
title: hyd1d & hydflood3
subtitle: R-Pakete zur Interpolation von 1D-Wasserspiegellagen mit Pegeldaten und zur Überflutungsdauerberechnung
author: Arnd Weber, Marcus Hatz, Wolfgang Stürmer, Wilfried Wiechmann
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  revealjs::revealjs_presentation:
    theme: white
    css: ../presentation/presentation.css
    highlight: pygments
    self_contained: true
    center: true
    transition: none
    fig_width: 9
    fig_height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, message = FALSE)
```

# Wie erhält man Wasserstandsinformationen für einen Punkt oder eine Strecke an einer Bundeswasserstraße zu einem ausgewählten Zeitpunkt? {#problemstellung}

## {#problemstellung-karte data-background="map.png" data-background-size="auto 800px"}

## 21.12.2016 {#problemstellung-karte-date data-background="screenshot_hydflood3_20161221.png" data-background-size="auto 800px"}

# PEGELONLINE {#po}

## Abfrage der nächstgelegenen Pegel {#po-query}

- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=501490>
- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=502000>

## {#po-query-rosslau data-background="screenshot_pegelonline_Rosslau.png" data-background-size="auto 750px"}

## {#po-query-dessau data-background="screenshot_pegelonline_Dessau.png" data-background-size="auto 750px"}

## Wasserstand der angrenzenden Pegel {#po-res1}

```{r pegelonline-res1}
# standard library path for the installed local packages
R_version <- paste(sep = ".", R.Version()$major, R.Version()$minor)
lib <- paste0("~/R/", R_version, "/")
require(hyd1d, lib.loc = lib)
require(plotrix, lib.loc = lib)

cex_legend <- 0.7

xlim_min <- 257
xlim_max <- 263
ylim_min <- 53.8
ylim_max <- 55.8
wldf <- WaterLevelDataFrame(river = "Elbe",
                            time = as.POSIXct("2016-12-21"),
                            station = seq(257, 262, 0.1))
wldf1 <- waterLevel(wldf, TRUE)
gs <- getGaugingStations(wldf1)
id <- gs$km_qps >= xlim_min & gs$km_qps <= xlim_max
lm_pegelonline <- lm(wl ~ km_qps, data = gs[id, ])

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Lineare Interpolation {#po-res2}

```{r pegelonline-res2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    #abline(lm_pegelonline, col = "darkblue")
    lines(x = gs$km_qps, y = gs$wl, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

# FLYS

## Einleitung {#flys-intro}

> - **FLYS** ist kein hydraulisches Modell, sondern eine Plattform zur Ausgabe 
und Interpolation von Modellergebnissen.
> - **FLYS** stellt 30 stationäre Wasserspiegellagen für gleichwertige 
Abflusslängsschnitte von 0.5MNQ bis HQ500 aus 1D-SOBEK-Berechnungen bereit.
> - <https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html>
> - Quellcode verfügbar auf <http://www.dive4elements.org>

## Verfügbare Wasserspiegellagen {#flys-wsl}

```{r flys-wsl}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g", 
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75", 
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62), 
         xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
}
```

## Ausgewählte Wasserspiegellagen {#flys-wsl-sel1}

```{r flys-wsl-sel1}
mq_0.5 <- waterLevelFlys3(wldf, "0.5MQ")
a <- waterLevelFlys3(wldf, "a")
mq_0.75 <- waterLevelFlys3(wldf, "0.75MQ")
mq <- waterLevelFlys3(wldf, "MQ")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    lines(mq_0.5$station, mq_0.5$w, col = "darkblue")
    lines(a$station, a$w, col = "darkblue")
    lines(mq_0.75$station, mq_0.75$w, col = "darkblue")
    text(262, min(mq_0.5$w), "0.5MQ", pos = 4, cex = 1)
    text(262, min(a$w), "a", pos = 4, cex = 1)
    text(262, min(mq_0.75$w), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel2}

```{r flys-wsl-sel2}
wldf2 <- waterLevelFlys3InterpolateY(wldf, "WITTENBERG", shiny = TRUE)
wldf3 <- waterLevelFlys3InterpolateY(wldf, "ROSSLAU", shiny = TRUE)
wldf4 <- waterLevelFlys3InterpolateY(wldf, "DESSAU", shiny = TRUE)

{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    #text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel3}

```{r flys-wsl-sel3}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    #lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel4}

```{r flys-wsl-sel4}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel5}

```{r flys-wsl-sel5}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel6}

```{r flys-wsl-sel6}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # difference
    id_sel <- which(wldf1$station == 260)
    arrows(x0 = 260, y0 = wldf3$w[id_sel], y1 = wldf4$w[id_sel], length = 0.13, 
           code = 3, col = "red", lwd = 3)
    text(260, (wldf3$w[id_sel] + wldf4$w[id_sel])/2, 
         labels = paste(round(wldf4$w[id_sel] - wldf3$w[id_sel], 2), "m"), 
         pos = 4, col = "red", font = 2)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Vergleich der Wasserspiegellagen {#flys-wsl-sel7}

```{r flys-wsl-sel7}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # pegelonline comparison
    po <- approx(x = gs$km_qps, y = gs$wl, 
                 xout = c(xlim_min, gs$km_qps[id], 262))
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1), lwd = c(0, 1),
           pch = c(21, NA), col = c("darkblue", "red"), 
           pt.bg = c("darkblue", NA), pt.cex = c(1, NA),
           legend = c("Wasserstand", "PEGELONLINE"), cex = cex_legend, 
           bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}

```

## Zusammenfassung {#flys-summary}

> - **FLYS** interpoliert stationäre Wasserspiegellagen abschnittsweise mit 
jeweils einem Bezugspegel.
> - Die Auswahl des Bezugspegels und dessen relativer Abfluss kann starken 
Einfluss auf die resultierende Wasserspiegellage haben.
> - Ungleichwertige Abflüsse großer Nebengewässern können Differenzen von 
mehreren Dezimetern zwischen mit **FLYS** abschnittsweise berechneten 
Wasserspiegellagen verursachen.
> - Sprünge, bzw. Diskontinuitäten an Abschnittsgrenzen sind daher unvermeidbar.

# hyd1d

## Einleitung {#hyd1d-intro}

> - **hyd1d** ist als **R**-Paket programmiert und soll über [CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht werden.
> - **hyd1d** integriert Paket-eigene Pegeldaten aus der
[HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html), 
aktuelle Pegeldaten von [PEGELONLINE](https://pegelonline.wsv.de), und 
Wasserspiegellagen von [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html).
> - Pegel- und Wasserspiegeldaten werden so miteinander interpoliert, dass 
resultierenden Wasserspiegellagen auch über lange Strecken keine 
Diskontinuitäten aufweisen.

## Methodik {#hyd1d-method}

1. Bestimmung der relevanten Pegel für den Berechnungsort, bzw. die
Berechnungsstrecke
2. Bestimmung der Wasserstände dieser Pegeln zum gewählten Zeitpunkt
3. Aufteilung der Berechnungsstrecke in Abschnitte, die von jeweils zwei Pegeln 
eingerahmt werden
4. Abschnittsweise Bestimmung, welche FLYS-Wasserspiegellagen die 
Wasserspiegellagen an den beiden Pegeln einrahmen
5. Abschnittsweise, entfernungsabhängige Interpolation zwischen den einrahmenden
FLYS-Wasserspiegellagen

## 1. Streckenrelevante Pegel {#hyd1d-method-1}

```{r hyd1d-method-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # berechnungsstrecke
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
}
```

## 2. Wasserstände {#hyd1d-method-2}

```{r hyd1d-method-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", box.col = "white")
    box()
}
```

## 3. Aufteilung der Berechnungsstrecke {#hyd1d-method-3}

```{r hyd1d-method-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # sections
    for (i in 1:(nrow(gs) - 1)) {
        rect(gs$km_qps[i], 53, gs$km_qps[i + 1], 54, col = "lightblue", border = NA)
        text((gs$km_qps[i] + gs$km_qps[i + 1])/2, 53.5, i, font = 2)
        lines(rep(gs$km_qps[i], 2), c(53, 54), lwd = 2)
        lines(rep(gs$km_qps[i + 1], 2), c(53, 54), lwd = 2)
    }
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", 
           box.col = "white")
    box()
}
```

## 4. Einrahmende Wasserspiegellagen {#hyd1d-method-4}

```{r hyd1d-method-4}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
              col = "darkblue")
    }
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i], col = "darkblue")
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "darkblue")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(a$w[i]), "a", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## 5.1 Gewichtung an den Pegeln {#hyd1d-method-5-1}

```{r hyd1d-method-5-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.52)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 4,
         font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 2,
         font = 2, col = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(257.8, max(mq_0.5$w[i]), "0", pos = 2, font = 2)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    text(257.8, max(mq_0.75$w[i]), "1", pos = 2, font = 2, col = "red")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA), 
           lty = c(0, 0, 1, 1), 
           legend = c("Wasserstand", "Gewicht", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.font = c(1, 2, 1, 1), 
           text.col = c(1, "darkblue", 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.2 Gewichtung entlang der Strecke {#hyd1d-method-5-2}

```{r hyd1d-method-5-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(-0.1, 1.1), xlab = "Flusskilometer (km)", 
         ylab = "relatives Gewicht")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], -0.05, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 1.05, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 1.05, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # weighting
    lines(x = c(gs$km_qps[id][1], gs$km_qps[id][2]),
          y = c(gs$weight_up[id][1], gs$weight_do[id][2]))
    points(gs$km_qps[id][1], gs$weight_up[id][1], pch = 21, col = 1, bg = 1)
    points(gs$km_qps[id][2], gs$weight_do[id][2], pch = 21, col = 1, bg = 1)
    text(gs$km_qps[id][1], gs$weight_up[id][1], round(gs$weight_up[id][1], 2), 
         pos = 2, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$weight_do[id][2], round(gs$weight_do[id][2], 2), 
         pos = 4, font = 2, col = "darkblue")
}
```

## 5.3 Interpolation der Wasserspiegellage {#hyd1d-method-5-3}

```{r hyd1d-method-5-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    lines(wldf1$station[i], wldf1$w[i], col = "darkblue", lwd = 2)
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 2,
         cex = 1, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 4,
         cex = 1, font = 2, col = "darkblue")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           text.font = c(1, 2, 1, 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.4 Interpolationen zusammengefasst {#hyd1d-method-5-4}

```{r hyd1d-method-5-4}
{
    par(cex = 1.2)
    plotShiny(wldf1, TRUE, TRUE, TRUE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmark
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 0.7, border = FALSE, col = "blue", 
                 srt = 90)
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           cex = cex_legend, bty = "n")
    box()
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp1}

```{r hyd1d-wsl-comp1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1), lwd = c(0, 1),
           pch = c(21, NA), col = c("darkblue", "red"), 
           pt.bg = c("darkblue", NA), pt.cex = c(1, NA),
           legend = c("Wasserstand", "PEGELONLINE"), cex = cex_legend, 
           bty = "n")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp2}

```{r hyd1d-wsl-comp2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1, 1), lwd = c(0, 1, 1),
           pch = c(21, NA, NA), col = c("darkblue", "red", "darkblue"), 
           pt.bg = c("darkblue", NA, NA), pt.cex = c(1, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS"), cex = cex_legend, 
           bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp3}

```{r hyd1d-wsl-comp3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lines
    lines(x = po$x, y = po$y, col = "red")
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    lines(wldf1$station, wldf1$w, lty = 1, col = "black", lwd = 2)
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1, 1, 1), lwd = c(0, 1, 1, 2), pch = c(21, NA, NA, NA),
           col = c("darkblue", "red", "darkblue", "black"), 
           pt.bg = c("darkblue", NA, NA, NA), pt.cex = c(1, NA, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS", "hyd1d"), 
           cex = cex_legend, text.col = c("darkblue", "red", "darkblue", 
                                          "black"), bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Zusammenfassung {#hyd1d-summary}

> - **hyd1d** interpoliert stationäre Wasserspiegellagen von **FLYS** 
abschnittsweise mit Hilfe der umliegenden Pegel.
> - Die Interpolation wird mit **allen** für den Zeitpunkt und den
Gewässerabschnitt verfügbaren Pegeldaten durchgeführt.
> - Ungleichwertige Abflüsse großer Nebengewässer werden durch die Pegel 
abgebildet.
> - Sprünge, bzw. Diskontinuitäten werden durch das abschnittssweise 
Aufhängen der resultierenden Wasserspiegellage an den Pegeln unmöglich.

# Das R-Paket 

## Installation {#hyd1d-install}

- Bisher ist **hyd1d** nur innerhalb der BfG verfügbar und kann mit folgenden 
Befehlen installiert werden:
```{r hyd1d-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_git("git://apps.bafg.de/gitbucket/webera/hyd1d.git")
```

- Nach einer Veröffentlichung auf [CRAN](https://cran.r-project.org) reicht eine 
Zeile zur Installation:
```{r hyd1d-install2, eval = FALSE, echo = TRUE}
install.packages("hyd1d")
```

- Vor der Verwendung muss es dann nur noch geladen werden:
```{r hyd1d-install3, eval = FALSE, echo = TRUE}
library("hyd1d")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-1}

> - Eine S4-Klasse auf Basis der S3-Klasse `data.frame`
> - In diesem wird intern die Wasserspiegellage abgelegt.
> - 8 weitere Slots beinhalten alle weiteren relevanten Informationen.

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-2}

```{r hyd1d-s4-2}
str(wldf1, max.level = 2, vec.len = 3, width = 160, strict.width = "cut")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-3}

```{r hyd1d-s4-3}
head(as.data.frame(wldf1))
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-4}

```{r hyd1d-s4-4}
str(wldf1@gauging_stations, max.level = 2, vec.len = 3, width = 160, 
    strict.width = "cut")
```

## waterLevel...()-Funktionen {#hyd1d-waterLevel}

> - [waterLevelFlut1()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlut1.html)
> - [waterLevelFlys3()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3.html)
> - [waterLevelFlys3InterpolateX()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3InterpolateX.html)
> - [waterLevelFlys3InterpolateY()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3InterpolateY.html)
> - [waterLevel()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevel.html)
> - [waterLevelPegelonline()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevel.html)

## {#hyd1d-references data-background-iframe="http://hpc-service.bafg.de/~WeberA/hyd1d/reference/index.html"}

# hydflood3

## Einleitung {#hydflood3-intro}

> - **hydflood3** ist als **R**-Paket programmiert und soll über [CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht werden.
> - **hydflood3** dient der Berechnung von Überflutungsflächen und -dauern,
äquivalent zum INFORM-Modul Flut 3.
> - Wasserspiegellagen, die mittels **hyd1d** berechnet wurden, werden über 
Querprofilflächen in die Aue extrapoliert und mit digitalen Geländemodellen 
(DGM's) verglichen.

## Datengrundlagen {#hydflood3-data}

1. Querprofilspuren aus den SOBEK-Modellen für FLYS, umgerechnet zu Querprofilflächen
2. Wasserspiegellagen von **hyd1d**
3. Digitale Geländemodelle

## {#hydflood3-data-csa1 data-background="screenshot_hydflood3_crosssections.png" data-background-size="auto 800px"}

## {#hydflood3-data-csa2 data-background="screenshot_hydflood3_crosssectionareas.png" data-background-size="auto 800px"}

## {#hydflood3-data-csa3 data-background="screenshot_hydflood3_crosssectionareas_cs.png" data-background-size="auto 800px"}

## {#hydflood3-data-dem data-background="screenshot_hydflood3_dem.png" data-background-size="auto 800px"}

## flood3()-Funktion {#hydflood3-algorythm}

1. Berechnung der Wasserspiegellage
2. Übertrag der Wasserspiegellage über das Feld `station_int` auf die 
Querprofilflächen
3. $ufd[qpf > dgm] = ufd[qpf > dgm] + 1$
4. gegebenenfalls Wiederholung über eine Sequenz von Zeitschritten

## 21.12.2016 {#hydflood3-algorythm1 data-background="screenshot_hydflood3_20161221.png" data-background-size="auto 800px"}

## {#hydflood3-algorythm2 data-background="screenshot_hydflood3_20161221_video.png" data-background-size="auto 800px"}

## {#hydflood3-video data-background-video="flood3-2fps.mp4"}

## 2002 {#hydflood3-algorythm3 data-background="screenshot_hydflood3_2002.png" data-background-size="auto 800px"}

## 2016 {#hydflood3-algorythm4 data-background="screenshot_hydflood3_2016.png" data-background-size="auto 800px"}

## Vergleich von Überflutungsdauern {#hydflood3-comp}

- Es fehlt ein Vergleich zwischen den Überflutungsdauern nach **flood3** und 
einem instationären 2D- oder 3D-Hydraulik-Modell.

## Zusammenfassung {#hydflood3-summary}

> - **hydflood3** verwendet interpolierte Wasserspiegellagen von **hyd1d**, um 
mittels der Funktion `flood3()` Überflutungsflächen und -dauern zu berechnen.
> - Vorteile:
>     * wenige, bereits vorhandene Eingangsdatensätze (DGM, Querprofilspuren, Pegeldaten)
>     * hohe räumliche und zeitliche Auflösung
>     * kachelweise parallelisierbare, schnelle und großflächige Berechnung
> - Nachteil:
>     * kein physikalisches Modell, Flächen ohne Zufluss werden überflutet

# Das R-Paket 

## Installation {#hydflood3-install}

- Bisher ist **hydflood3** nur innerhalb der BfG verfügbar und kann mit folgenden 
Befehlen installiert werden:
```{r hydflood3-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_git("git://apps.bafg.de/gitbucket/webera/hydflood3.git")
```

- Nach einer Veröffentlichung auf [CRAN](https://cran.r-project.org) reicht eine 
Zeile zur Installation:
```{r hydflood3-install2, eval = FALSE, echo = TRUE}
install.packages("hydflood3")
```

- Vor der Verwendung muss es dann nur noch geladen werden:
```{r hydflood3-install3, eval = FALSE, echo = TRUE}
library("hydflood3")
```

## {#hydflood3-references data-background-iframe="http://hpc-service.bafg.de/~WeberA/hydflood3/reference/index.html"}

# Produkte

## {#product-waterlevels data-background="screenshot_hyd1d_products.png"}

## {#product-shiny-waterlevel data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/05-waterlevel/"}

## {#product-shiny-waterlevelpegelonline data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/06-waterlevelpegelonline/"}

## {#product-raster data-background="screenshot_hydflood3_products.png"}

## Zusammenfassung {#product-summary}

> - R-Pakete
> - 1D-Wasserspiegellagen für Rhein und Elbe seit dem 01.01.1990
> - Shiny-Services zur interaktiven Berechnung von Wasserspiegellagen
> - jährliche Überflutungsdauern als Rasterdatensätze
> - langjährig gemittelte Überflutungsdauerrasterdatensätze

# Veröffentlichung

## hyd1d

> - OpenSource-Software in [R](https://cran.r-project.org)
> - Dokumentationswebseite
> - beinhaltet eine Veröffentlichung von
[FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen 
und [HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html)-Pegeldaten
> - 1D-Wasserspiegellagen für Rhein und Elbe seit dem 01.01.1990
> - Shiny-Services [waterLevel()](http://hpc-service.bafg.de/shiny/WeberA/05-waterlevel/) 
und [waterLevelPegelonline()](http://hpc-service.bafg.de/shiny/WeberA/06-waterlevelpegelonline/)
> - Einbettung der Shiny-Services in FLYS 3.3

## hydflood3

> - OpenSource-Software in [R](https://cran.r-project.org)
> - Dokumentationswebseite
> - jährliche Überflutungsdauerraster von 1990 bis 2017
> - langjährig aggregierte Überflutungsdauerraster
> - WMS-Dienste der jährlichen und aggregierten Überflutungsdauerraster
> - Einbettung der WMS-Dienste in FLYS 3.3

## {#publication data-background-iframe="https://www.journals.elsevier.com/environmental-modelling-and-software"}

# Fragen?

# Vielen Dank für Ihre Aufmerksamkeit

# {#contact data-background="contact.png"}


