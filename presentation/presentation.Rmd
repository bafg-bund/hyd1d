---
title: hyd1d & hydflood3
subtitle: R-Pakete zur Interpolation von 1D-Wasserspiegellagen mit Pegeldaten und zur Überflutungsdauerberechnung
author: Arnd Weber, Marcus Hatz, Stephan Rosenzweig
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  revealjs::revealjs_presentation:
    theme: white
    css: ../presentation/presentation.css
    highlight: pygments
    self_contained: true
    center: true
    transition: none
    fig_width: 9
    fig_height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, message = FALSE)
```

# Wie erhält man Wasserstandsinformationen für einen Punkt oder eine Strecke an einer Bundeswasserstraße zu einem ausgewählten Zeitpunkt? {#problemstellung data-background="background.png" data-background-size="auto 800px"}

## {#problemstellung-karte data-background="map.png" data-background-size="auto 800px"}

## 21.12.2016 {#problemstellung-karte-date data-background="screenshot_hydflood3_20161221.png" data-background-size="auto 800px"}

## Wie aggregiert man diese flächige Wasserstandsinformation über die Zeit zu Überflutungsdauern? {#problemstellung-flood1 data-background="background.png" data-background-size="auto 800px"}

## Wie aggregiert man diese flächige Wasserstandsinformation über die Zeit zu Überflutungsdauern? {#problemstellung-flood2 data-background="background.png" data-background-size="auto 800px"}

[http://hpc-service.bafg.de/shiny/WeberA/07-flood3/](http://hpc-service.bafg.de/shiny/WeberA/07-flood3/)

# PEGELONLINE {#po data-background="background.png" data-background-size="auto 800px"}

## Abfrage der nächstgelegenen Pegel {#po-query data-background="background.png" data-background-size="auto 800px"}

- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=501490>
- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=502000>

## {#po-query-rosslau data-background="screenshot_pegelonline_Rosslau.png" data-background-size="auto 750px"}

## {#po-query-dessau data-background="screenshot_pegelonline_Dessau.png" data-background-size="auto 750px"}

## Wasserstände der angrenzenden Pegel {#po-res1 data-background="background.png" data-background-size="auto 800px"}

```{r pegelonline-res1}
# standard library path for the installed local packages
R_version <- paste(sep = ".", R.Version()$major, R.Version()$minor)
lib <- paste0("~/R/", R_version, "/")
require(hyd1d, lib.loc = lib)
require(hydflood3, lib.loc = lib)
require(plotrix, lib.loc = lib)

cex_legend <- 0.7

xlim_min <- 257
xlim_max <- 263
ylim_min <- 53.8
ylim_max <- 55.8
wldf <- WaterLevelDataFrame(river = "Elbe",
                            time = as.POSIXct("2016-12-21"),
                            station = seq(257, 262, 0.1))
wldf1 <- waterLevel(wldf, TRUE)
gs <- getGaugingStations(wldf1)
id <- gs$km_qps >= xlim_min & gs$km_qps <= xlim_max
lm_pegelonline <- lm(wl ~ km_qps, data = gs[id, ])

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Lineare Interpolation {#po-res2 data-background="background.png" data-background-size="auto 800px"}

```{r pegelonline-res2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    #abline(lm_pegelonline, col = "darkblue")
    lines(x = gs$km_qps, y = gs$wl, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

# FLYS {#flys data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#flys-intro data-background="background.png" data-background-size="auto 800px"}

> - [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) ist kein hydraulisches Modell, sondern eine Plattform zur Ausgabe 
und Interpolation von Modellergebnissen.
> - [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) stellt 30 stationäre Wasserspiegellagen für gleichwertige 
Abflusslängsschnitte von 0.5MNQ bis HQ500 aus 1D-SOBEK-Berechnungen bereit.
> - <https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html>
> - Quellcode verfügbar auf <http://www.dive4elements.org>

## Verfügbare Wasserspiegellagen {#flys-wsl1}

```{r flys-wsl1}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g", 
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75", 
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62), 
         xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
}
```

## Verfügbare Wasserspiegellagen {#flys-wsl2}

```{r flys-wsl2}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g", 
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75", 
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62), 
         xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Ausgewählte Wasserspiegellagen {#flys-wsl-sel1 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel1}
mq_0.5 <- waterLevelFlys3(wldf, "0.5MQ")
a <- waterLevelFlys3(wldf, "a")
mq_0.75 <- waterLevelFlys3(wldf, "0.75MQ")
mq <- waterLevelFlys3(wldf, "MQ")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    lines(mq_0.5$station, mq_0.5$w, col = "darkblue")
    lines(a$station, a$w, col = "darkblue")
    lines(mq_0.75$station, mq_0.75$w, col = "darkblue")
    text(262, min(mq_0.5$w), "0.5MQ", pos = 4, cex = 1)
    text(262, min(a$w), "a", pos = 4, cex = 1)
    text(262, min(mq_0.75$w), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel2 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel2}
wldf2 <- waterLevelFlys3InterpolateY(wldf, "WITTENBERG", shiny = TRUE)
wldf3 <- waterLevelFlys3InterpolateY(wldf, "ROSSLAU", shiny = TRUE)
wldf4 <- waterLevelFlys3InterpolateY(wldf, "DESSAU", shiny = TRUE)

{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    #text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel3 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel3}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    #lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel4 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel4}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel5 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel5}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel6 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel6}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # difference
    id_sel <- which(wldf1$station == 260)
    arrows(x0 = 260, y0 = wldf3$w[id_sel], y1 = wldf4$w[id_sel], length = 0.13, 
           code = 3, col = "red", lwd = 3)
    text(260, (wldf3$w[id_sel] + wldf4$w[id_sel])/2, 
         labels = paste(round(wldf4$w[id_sel] - wldf3$w[id_sel], 2), "m"), 
         pos = 4, col = "red", font = 2)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Vergleich der Wasserspiegellagen {#flys-wsl-sel7 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel7}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # pegelonline comparison
    po <- approx(x = gs$km_qps, y = gs$wl, 
                 xout = c(xlim_min, gs$km_qps[id], 262))
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1), lwd = c(0, 1),
           pch = c(21, NA), col = c("darkblue", "red"), 
           pt.bg = c("darkblue", NA), pt.cex = c(1, NA),
           legend = c("Wasserstand", "PEGELONLINE"), cex = cex_legend, 
           bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}

```

## Zusammenfassung {#flys-summary data-background="background.png" data-background-size="auto 800px"}

> - [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) interpoliert stationäre Wasserspiegellagen abschnittsweise mit 
jeweils einem Bezugspegel.
> - Die Auswahl des Bezugspegels und dessen relativer Abfluss kann starken 
Einfluss auf die resultierende Wasserspiegellage haben.
> - Ungleichwertige Abflüsse großer Nebengewässer können Differenzen von 
mehreren Dezimetern zwischen mit [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) abschnittsweise berechneten 
Wasserspiegellagen verursachen.
> - Sprünge, bzw. Diskontinuitäten an Abschnittsgrenzen sind daher unvermeidbar.

# hyd1d {#hyd1d data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#hyd1d-intro data-background="background.png" data-background-size="auto 800px"}

> - **hyd1d** ist als **R**-Paket programmiert und soll über [CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht werden.
> - **hyd1d** integriert Paket-eigene Pegeldaten aus der
[HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html), 
aktuelle Pegeldaten von [PEGELONLINE](https://pegelonline.wsv.de), und 
Wasserspiegellagen von [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html).
> - Pegel- und Wasserspiegeldaten werden so miteinander interpoliert, dass 
resultierenden Wasserspiegellagen auch über lange Strecken keine 
Diskontinuitäten aufweisen.

## Methodik {#hyd1d-method data-background="background.png" data-background-size="auto 800px"}

1. Bestimmung der relevanten Pegel für den Berechnungsort, bzw. die
Berechnungsstrecke
2. Bestimmung der Wasserstände dieser Pegeln zum gewählten Zeitpunkt
3. Aufteilung der Berechnungsstrecke in Abschnitte, die von jeweils zwei Pegeln 
eingerahmt werden
4. Abschnittsweise Bestimmung, welche [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen die 
Wasserspiegellagen an den beiden Pegeln einrahmen
5. Abschnittsweise, entfernungsabhängige Interpolation zwischen den einrahmenden
[FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen

## 1. Streckenrelevante Pegel {#hyd1d-method-1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # berechnungsstrecke
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
}
```

## 2. Wasserstände {#hyd1d-method-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", box.col = "white")
    box()
}
```

## 3. Aufteilung der Berechnungsstrecke {#hyd1d-method-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8), 
         ylim = c(51, 58), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # sections
    for (i in 1:(nrow(gs) - 1)) {
        rect(gs$km_qps[i], 53, gs$km_qps[i + 1], 54, col = "lightblue", border = NA)
        text((gs$km_qps[i] + gs$km_qps[i + 1])/2, 53.5, i, font = 2)
        lines(rep(gs$km_qps[i], 2), c(53, 54), lwd = 2)
        lines(rep(gs$km_qps[i + 1], 2), c(53, 54), lwd = 2)
    }
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "o", 
           box.col = "white")
    box()
}
```

## 4. Einrahmende Wasserspiegellagen {#hyd1d-method-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-4}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2, 
              col = "darkblue")
    }
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i], col = "darkblue")
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "darkblue")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(a$w[i]), "a", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", 
           pch = 21, col = "darkblue", pt.bg = "darkblue", pt.cex = 1,
           legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## 5.1 Gewichtung an den Pegeln {#hyd1d-method-5-1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.52)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 4,
         font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 2,
         font = 2, col = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(257.8, max(mq_0.5$w[i]), "0", pos = 2, font = 2)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    text(257.8, max(mq_0.75$w[i]), "1", pos = 2, font = 2, col = "red")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA), 
           lty = c(0, 0, 1, 1), 
           legend = c("Wasserstand", "Gewicht", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.font = c(1, 2, 1, 1), 
           text.col = c(1, "darkblue", 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.2 Gewichtung entlang der Strecke {#hyd1d-method-5-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(-0.1, 1.1), xlab = "Flusskilometer (km)", 
         ylab = "relatives Gewicht")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], -0.05, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 1.05, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 1.05, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # weighting
    lines(x = c(gs$km_qps[id][1], gs$km_qps[id][2]),
          y = c(gs$weight_up[id][1], gs$weight_do[id][2]))
    points(gs$km_qps[id][1], gs$weight_up[id][1], pch = 21, col = 1, bg = 1)
    points(gs$km_qps[id][2], gs$weight_do[id][2], pch = 21, col = 1, bg = 1)
    text(gs$km_qps[id][1], gs$weight_up[id][1], round(gs$weight_up[id][1], 2), 
         pos = 2, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$weight_do[id][2], round(gs$weight_do[id][2], 2), 
         pos = 4, font = 2, col = "darkblue")
}
```

## 5.3 Interpolation der Wasserspiegellage {#hyd1d-method-5-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    lines(wldf1$station[i], wldf1$w[i], col = "darkblue", lwd = 2)
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 2,
         cex = 1, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 4,
         cex = 1, font = 2, col = "darkblue")
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           text.font = c(1, 2, 1, 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.4 Interpolationen zusammengefasst {#hyd1d-method-5-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-4}
{
    par(cex = 1.2)
    plotShiny(wldf1, TRUE, TRUE, TRUE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmark
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 0.7, border = FALSE, col = "blue", 
                 srt = 90)
    
    # legend
    legend("topright", 
           col = c("darkblue", "darkblue", "darkblue", "red", "black"), 
           pch = c(21, NA, NA, NA, NA), 
           pt.bg = c("darkblue", NA, NA, NA, NA), 
           pt.cex = c(1, NA, NA, NA, NA), 
           lty = c(0, 0, 1, 1, 1), 
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS-WSL", 
                      "untere FLYS-WSL"), 
           text.col = c(1, "darkblue", 1, 1, 1),
           cex = cex_legend, bty = "n")
    box()
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1), lwd = c(0, 1),
           pch = c(21, NA), col = c("darkblue", "red"), 
           pt.bg = c("darkblue", NA), pt.cex = c(1, NA),
           legend = c("Wasserstand", "PEGELONLINE"), cex = cex_legend, 
           bty = "n")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1, 1), lwd = c(0, 1, 1),
           pch = c(21, NA, NA), col = c("darkblue", "red", "darkblue"), 
           pt.bg = c("darkblue", NA, NA), pt.cex = c(1, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS"), cex = cex_legend, 
           bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), 
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)", 
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1, 
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1, 
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lines
    lines(x = po$x, y = po$y, col = "red")
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    lines(wldf1$station, wldf1$w, lty = 1, col = "black", lwd = 2)
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue", 
           bg = "darkblue")
    
    # legend
    legend("topright", 
           lty = c(0, 1, 1, 1), lwd = c(0, 1, 1, 2), pch = c(21, NA, NA, NA),
           col = c("darkblue", "red", "darkblue", "black"), 
           pt.bg = c("darkblue", NA, NA, NA), pt.cex = c(1, NA, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS", "hyd1d"), 
           cex = cex_legend, text.col = c("darkblue", "red", "darkblue", 
                                          "black"), bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Zusammenfassung {#hyd1d-summary data-background="background.png" data-background-size="auto 800px"}

> - **hyd1d** interpoliert stationäre Wasserspiegellagen von [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) 
abschnittsweise mit Hilfe der umliegenden Pegel.
> - Die Interpolation wird mit **allen** für den Zeitpunkt und den
Gewässerabschnitt verfügbaren Pegeldaten durchgeführt.
> - Ungleichwertige Abflüsse großer Nebengewässer werden durch die Pegel 
abgebildet.
> - Sprünge, bzw. Diskontinuitäten werden durch das abschnittssweise 
Aufhängen der resultierenden Wasserspiegellage an den Pegeln unmöglich.

# Das R-Paket {#hyd1d-package data-background="background.png" data-background-size="auto 800px"}

## Installation {#hyd1d-install data-background="background.png" data-background-size="auto 800px"}

- Bisher ist **hyd1d** nur innerhalb der BfG verfügbar und kann mit folgenden 
Befehlen installiert werden:
```{r hyd1d-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_git("git://apps.bafg.de/gitbucket/webera/hyd1d.git")
```

- Nach einer Veröffentlichung auf [CRAN](https://cran.r-project.org) reicht eine 
Zeile zur Installation, eine weitere zum Laden:
```{r hyd1d-install2, eval = FALSE, echo = TRUE}
install.packages("hyd1d")
library("hyd1d")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-1 data-background="background.png" data-background-size="auto 800px"}

> - Eine S4-Klasse auf Basis der S3-Klasse `data.frame`
> - In diesem wird intern die Wasserspiegellage abgelegt.
> - 8 weitere Slots beinhalten alle weiteren berechnungs- und darstellungsrelevanten Informationen.

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-2}
str(wldf1, max.level = 2, vec.len = 3, width = 160, strict.width = "cut")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-3}
head(as.data.frame(wldf1))
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-4}
str(wldf1@gauging_stations, max.level = 2, vec.len = 3, width = 160, 
    strict.width = "cut")
```

## waterLevel...()-Funktionen {#hyd1d-waterLevel data-background="background.png" data-background-size="auto 800px"}

> - [waterLevelFlut1()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlut1.html)
> - [waterLevelFlys3()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3.html)
> - [waterLevelFlys3InterpolateX()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3InterpolateX.html)
> - [waterLevelFlys3InterpolateY()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevelFlys3InterpolateY.html)
> - [waterLevel()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevel.html)
> - [waterLevelPegelonline()](http://hpc-service.bafg.de/~WeberA/hyd1d/reference/waterLevel.html)

## {#hyd1d-references data-background-iframe="http://hpc-service.bafg.de/~WeberA/hyd1d/reference/index.html"}

# hydflood3 {#hydflood3 data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#hydflood3-intro data-background="background.png" data-background-size="auto 800px"}

> - **hydflood3** ist als **R**-Paket programmiert und soll über [CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht werden.
> - **hydflood3** dient der Berechnung von Überflutungsflächen und -dauern,
äquivalent zum INFORM-Modul Flut 3.
> - Wasserspiegellagen, die mittels **hyd1d** berechnet wurden, werden über 
Querprofilflächen in die Aue extrapoliert und mit digitalen Geländemodellen 
(DGM's) verglichen.

## Datengrundlagen {#hydflood3-data data-background="background.png" data-background-size="auto 800px"}

> - Querprofilspuren aus den SOBEK-Modellen für [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html), umgerechnet zu Querprofilflächen (`qpf`)
> - Wasserspiegellagen von **hyd1d**
> - Digitale Geländemodelle (`dgm`)

## {#hydflood3-data-csa1 data-background="screenshot_hydflood3_crosssections.png" data-background-size="auto 800px"}

## {#hydflood3-data-csa2 data-background="screenshot_hydflood3_crosssectionareas.png" data-background-size="auto 800px"}

## {#hydflood3-data-csa3 data-background="screenshot_hydflood3_crosssectionareas_cs.png" data-background-size="auto 800px"}

## {#hydflood3-data-dem data-background="screenshot_hydflood3_dem.png" data-background-size="auto 800px"}

## flood3()-Funktion {#hydflood3-algorythm data-background="background.png" data-background-size="auto 800px"}

> - Berechnung der Wasserspiegellage
> - Übertrag der Wasserspiegellage über das Join-Feld `station_int` auf die 
Querprofilflächen (`qpf`)
> - `ufd[qpf > dgm] = ufd[qpf > dgm] + 1`
> - gegebenenfalls Wiederholung über eine Sequenz von Zeitschritten

## 21.12.2016 {#hydflood3-algorythm1 data-background="screenshot_hydflood3_20161221.png" data-background-size="auto 800px"}

## {#hydflood3-algorythm2 data-background="screenshot_hydflood3_20161221_video.png" data-background-size="auto 800px"}

## {#hydflood3-video data-background-video="flood3-2fps-dessau.mp4"}

## 2002 {#hydflood3-algorythm3 data-background="screenshot_hydflood3_2002.png" data-background-size="auto 800px"}

## 2016 {#hydflood3-algorythm4 data-background="screenshot_hydflood3_2016.png" data-background-size="auto 800px"}

## Vergleich von Überflutungsdauern {#hydflood3-comp data-background="background.png" data-background-size="auto 800px"}

- Es fehlt ein Vergleich zwischen den Überflutungsdauern nach **flood3** und 
einem instationären 2D- oder 3D-Hydraulik-Modell und realen Messdaten.

## Zusammenfassung {#hydflood3-summary data-background="background.png" data-background-size="auto 800px"}

> - **hydflood3** verwendet interpolierte Wasserspiegellagen von **hyd1d**, um 
mittels der Funktion `flood3()` Überflutungsflächen und -dauern zu berechnen.
> - Vorteile:
>     * wenige, bereits vorhandene Eingangsdatensätze (DGM, Querprofilspuren, Pegeldaten)
>     * hohe räumliche und zeitliche Auflösung
>     * kachelweise parallelisierbare, schnelle und großflächige Berechnung
> - Nachteil:
>     * kein physikalisches Modell, auch Flächen ohne Zufluss werden überflutet

# Das R-Paket {#hydflood3-package data-background="background.png" data-background-size="auto 800px"}

## Installation {#hydflood3-install data-background="background.png" data-background-size="auto 800px"}

- Bisher ist **hydflood3** nur innerhalb der BfG verfügbar und kann mit folgenden 
Befehlen installiert werden:
```{r hydflood3-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_git("git://apps.bafg.de/gitbucket/webera/hydflood3.git")
```

- Nach einer Veröffentlichung auf [CRAN](https://cran.r-project.org) reicht eine 
Zeile zur Installation, eine weitere zum Laden:
```{r hydflood3-install2, eval = FALSE, echo = TRUE}
install.packages("hydflood3")
library("hydflood3")
```

## S4-Klasse hydRasterStack {#hydflood3-s4-1 data-background="background.png" data-background-size="auto 800px"}

> - Eine S4-Klasse auf Basis der S4-Klasse `RasterStack`
> - Beinhaltet RasterLayer des digitalen Geländemodells (`dgm`) und der Querprofilflächen (`qpf`).
> - eigene Datensätze sind verwendbar, ansonsten stehen Paket-eigene Querprofilfächen und downloadbare digitale Geländemodelle (`dgm`) zur Verfügung.
> - für diese automatisierte Erstellung eines `hydRasterStack` müssen nur die Ausdehnung (`ext`) und das Koordinatensystem (`crs`) angegeben werden.

## S4-Klasse hydRasterStack {#hydflood3-s4-2 data-background="background.png" data-background-size="auto 800px"}

- Initialisierung des `hydRasterStack` mit Nutzer-eigenen Datensätzen
```{r hydflood3-hydRasterStack1, eval = FALSE, echo = TRUE}
x <- hydRasterStack(filename_dem = "data-raw/raster.dem.tif",
                    filename_csa = "data-raw/raster.csa.tif")
```

- mit `extent(x)` und `CRS(x)` `hydRasterStack` initialisieren und Daten herunterladen 
```{r hydflood3-hydRasterStack2, eval = FALSE, echo = TRUE}
ext <- extent(x)
crs <- CRS(x)
x <- hydRasterStack(ext = ext, crs = crs)
```

## S4-Klasse hydRasterStack {#hydflood3-s4-3 data-background="background.png" data-background-size="auto 800px"}

```{r hydflood3-hydRasterStack-strprep, include = FALSE}
# mit eigenen Datensätzen
x <- hydRasterStack(filename_dem = "~/hydflood3/data-raw/raster.dem.tif",
                    filename_csa = "~/hydflood3/data-raw/raster.csa.tif")
```

```{r hydflood3-hydRasterStack-str}
str(x, max.level = 2, vec.len = 3, width = 160, strict.width = "cut")
```

## flood3() {#hydflood3-flood3 data-background="background.png" data-background-size="auto 800px"}

```{r hydflood3-flood, eval = FALSE, echo = TRUE}
# Initialisierung von x mit eigenen Datensätzen
x <- hydRasterStack(filename_dem = "data-raw/raster.dem.tif",
                    filename_csa = "data-raw/raster.csa.tif")

# Sequenz des Berechnungszeitraums
seq <- seq.Date(from = as.Date("2017-01-01"), 
                to = as.Date("2017-12-31"), 
                by = "day")

# Berechnung der Überflutungsdauer
ufd <- flood3(x = x, seq = seq)
```

## {#hydflood3-references data-background-iframe="http://hpc-service.bafg.de/~WeberA/hydflood3/reference/index.html"}

# Produkte {#products data-background="background.png" data-background-size="auto 800px"}

## {#product-waterlevels data-background="screenshot_hyd1d_products.png"}

## {#product-shiny-waterlevel data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/05-waterlevel/"}

## {#product-shiny-waterlevelpegelonline data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/06-waterlevelpegelonline/"}

## {#product-raster data-background="screenshot_hydflood3_products.png"}

## {#product-shiny-flood3 data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/07-flood3/"}

## {#product-shiny-flood3-wms data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/08-flood3wms/"}

# Veröffentlichung {#publication data-background="background.png" data-background-size="auto 800px"}

## hyd1d {#hyd1d-publication data-background="background.png" data-background-size="auto 800px"}

> - OpenSource-Package auf [CRAN](https://cran.r-project.org)
> - Dokumentationswebseite
> - beinhaltet eine Veröffentlichung von
[FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen 
und [HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html)-Pegeldaten
> - vorberechnete 1D-Wasserspiegellagen für Rhein und Elbe vom 01.01.1990 bis gestern
> - Shiny-Services [waterLevel()](http://hpc-service.bafg.de/shiny/WeberA/05-waterlevel/) 
und [waterLevelPegelonline()](http://hpc-service.bafg.de/shiny/WeberA/06-waterlevelpegelonline/)
> - Einbettung der Shiny-Services in [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) 3.3

## hydflood3 {#hydflood3-publication data-background="background.png" data-background-size="auto 800px"}

> - OpenSource-Package auf [CRAN](https://cran.r-project.org)
> - Dokumentationswebseite
> - beinhaltet eine (Wieder-)Veröffentlichung der 
[DGM-W](https://www.govdata.de/daten/-/details/1c669080-c804-11e4-8731-1681e6b88ec1bkg)'s und der Querprofilflächen
> - jährliche Überflutungsdauerraster von 1990 bis 2017
> - langjährig aggregierte Überflutungsdauerraster
> - WMS-Dienste der jährlichen und aggregierten Überflutungsdauerraster
> - Shiny-Services [flood3()](http://hpc-service.bafg.de/shiny/WeberA/07-flood3/) 
und [flood3()-WMS](http://hpc-service.bafg.de/shiny/WeberA/08-flood3wms/)
> - Einbettung der WMS-Dienste in [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) 3.3
> - Einbettung der Shiny-Services in [FLYS](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) 3.3

## {#publication-ems data-background-iframe="https://www.journals.elsevier.com/environmental-modelling-and-software"}

# {#flood3-result data-background-iframe="http://hpc-service.bafg.de/shiny/WeberA/07-flood3/?_state_id_=530c656e3abaa905"}

# Danke {#thanks data-background="background.png" data-background-size="auto 800px"}

> - Z2: Klaus Reuter, Kai Schramm
> - M1: Wilfried Wiechmann und das Team der Datenstelle M1, Lars Schumann
> - M2: Wolfgang Stürmer, Markus Promny, Bastian Klein, Thomas Recknagel
> - M3: Marcel Reiss
> - M4: Torsten Fay
> - U2: Jens Wyrwa, Beatrix Konz, Peter Horchler, Elmar Fuchs, Michael Schleuter

# Fragen? {#questions data-background="background.png" data-background-size="auto 800px"}

# Vielen Dank für Ihre Aufmerksamkeit {#thanks data-background="background.png" data-background-size="auto 800px"}

# {#contact data-background="contact.png"}

# {#lenzen data-background-video="flood3-2fps-lenzen.mp4"}
