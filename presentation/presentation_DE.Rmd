---
title: hyd1d & hydflood
subtitle: R-Pakete zur Interpolation von 1d-Wasserspiegellagen mit Pegeldaten und zur Überflutungsdauerberechnung
author: Arnd Weber, Marcus Hatz, Stephan Rosenzweig
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  revealjs::revealjs_presentation:
    theme: white
    css: presentation.css
    highlight: pygments
    self_contained: true
    center: true
    transition: none
    fig_width: 9
    fig_height: 6
vignette: |
  %\VignetteIndexEntry{hyd1d and hydflood}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, message = FALSE)
```

# Wie erhält man Wasserstandsinformationen für einen Punkt oder eine Strecke an einer Bundeswasserstraße zu einem ausgewählten Zeitpunkt? {#problemstellung data-background="background.png" data-background-size="auto 800px"}

## {#problemstellung-karte data-background="map.png" data-background-size="auto 800px"}

## 21.12.2016 {#problemstellung-karte-date data-background="screenshot_hydflood_20161221.png" data-background-size="auto 800px"}

## Wie aggregiert man diese flächige Wasserstandsinformation über die Zeit zu Überflutungsdauern? {#problemstellung-flood1 data-background="background.png" data-background-size="auto 800px"}

## Wie aggregiert man diese flächige Wasserstandsinformation über die Zeit zu Überflutungsdauern? {#problemstellung-flood2 data-background="background.png" data-background-size="auto 800px"}

[http://r.bafg.de/shiny/WeberA/07-flood3/](http://r.bafg.de/shiny/WeberA/07-flood3/)

# PEGELONLINE {#po data-background="background.png" data-background-size="auto 800px"}

## Abfrage der nächstgelegenen Pegel {#po-query data-background="background.png" data-background-size="auto 800px"}

- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=501490>
- <https://pegelonline.wsv.de/gast/stammdaten?pegelnr=502000>

## {#po-query-rosslau data-background="screenshot_pegelonline_Rosslau.png" data-background-size="auto 750px"}

## {#po-query-dessau data-background="screenshot_pegelonline_Dessau.png" data-background-size="auto 750px"}

## Wasserstände der angrenzenden Pegel {#po-res1 data-background="background.png" data-background-size="auto 800px"}

```{r pegelonline-res1}
require(hyd1d)
require(hydflood)
require(plotrix)

cex_legend <- 0.7

xlim_min <- 257
xlim_max <- 263
ylim_min <- 53.8
ylim_max <- 55.8
wldf <- WaterLevelDataFrame(river = "Elbe",
                            time = as.POSIXct("2016-12-21"),
                            station = seq(257, 262, 0.1))
wldf1 <- waterLevel(wldf, TRUE)
gs <- getGaugingStations(wldf1)
id <- gs$km_qps >= xlim_min & gs$km_qps <= xlim_max
lm_pegelonline <- lm(wl ~ km_qps, data = gs[id, ])

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Lineare Interpolation {#po-res2 data-background="background.png" data-background-size="auto 800px"}

```{r pegelonline-res2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    #abline(lm_pegelonline, col = "darkblue")
    lines(x = gs$km_qps, y = gs$wl, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

# FLYS3 {#flys data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#flys-intro data-background="background.png" data-background-size="auto 800px"}

> - [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
ist kein hydraulisches Modell, sondern eine Plattform zur Ausgabe und
Interpolation von Modellergebnissen
> - [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
stellt 30 stationäre Wasserspiegellagen für gleichwertige 
Abflusslängsschnitte von 0.5MNQ bis HQ500 aus 1d-SOBEK-Berechnungen bereit
> - <https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html>
> - Quellcode verfügbar auf <http://www.dive4elements.org>

## Verfügbare Wasserspiegellagen {#flys-wsl1 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl1}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g",
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75",
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62),
         xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2,
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
}
```

## Verfügbare Wasserspiegellagen {#flys-wsl2 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl2}
flys3_water_levels <- c("0.5MNQ", "MNQ", "0.5MQ", "a", "0.75MQ", "b", "MQ", "c",
                        "2MQ", "3MQ", "d", "e", "MHQ", "HQ2", "f", "HQ5", "g",
                        "h", "HQ10", "HQ15", "HQ20", "HQ25", "HQ50", "HQ75",
                        "HQ100", "i", "HQ150", "HQ200", "HQ300", "HQ500")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max), ylim = c(53, 62),
         xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        if (a_wl %in% c("0.5MNQ", "MNQ", "MQ", "MHQ", "HQ10", "HQ100", "HQ500")){
            lines(wldf_temp$station, wldf_temp$w, lty = 1, col = "darkblue")
            text(262.0, wldf_temp$w[nrow(wldf_temp)], a_wl, pos = 4, cex = 1)
        } else {
            lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2,
                  col = "darkblue")
        }
    }
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 53.5, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 61.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 61.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Ausgewählte Wasserspiegellagen {#flys-wsl-sel1 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel1}
mq_0.5 <- waterLevelFlys3(wldf, "0.5MQ")
a <- waterLevelFlys3(wldf, "a")
mq_0.75 <- waterLevelFlys3(wldf, "0.75MQ")
mq <- waterLevelFlys3(wldf, "MQ")

{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # FLYS
    lines(mq_0.5$station, mq_0.5$w, col = "darkblue")
    lines(a$station, a$w, col = "darkblue")
    lines(mq_0.75$station, mq_0.75$w, col = "darkblue")
    text(262, min(mq_0.5$w), "0.5MQ", pos = 4, cex = 1)
    text(262, min(a$w), "a", pos = 4, cex = 1)
    text(262, min(mq_0.75$w), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel2 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel2}
wldf2 <- waterLevelFlys3InterpolateY(wldf, "WITTENBERG", shiny = TRUE)
wldf3 <- waterLevelFlys3InterpolateY(wldf, "ROSSLAU", shiny = TRUE)
wldf4 <- waterLevelFlys3InterpolateY(wldf, "DESSAU", shiny = TRUE)

{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    #text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    #text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel3 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel3}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel4 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel4}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel5 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel5}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Interpolierte Wasserspiegellagen {#flys-wsl-sel6 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel6}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # difference
    id_sel <- which(wldf1$station == 260)
    arrows(x0 = 260, y0 = wldf3$w[id_sel], y1 = wldf4$w[id_sel], length = 0.13,
           code = 3, col = "red", lwd = 3)
    text(260, (wldf3$w[id_sel] + wldf4$w[id_sel])/2,
         labels = paste(round(wldf4$w[id_sel] - wldf3$w[id_sel], 2), "m"),
         pos = 4, col = "red", font = 2)
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}
```

## Vergleich der Wasserspiegellagen {#flys-wsl-sel7 data-background="background.png" data-background-size="auto 800px"}

```{r flys-wsl-sel7}
{
    par(cex = 1.2)
    plotShiny(wldf2, FALSE, FALSE, FALSE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    polygon(x = c(wldf3$station, rev(wldf4$station)),
            y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # pegelonline comparison
    po <- approx(x = gs$km_qps, y = gs$wl,
                 xout = c(xlim_min, gs$km_qps[id], 262))
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", lty = c(0, 1), lwd = c(0, 1), pch = c(21, NA),
           col = c("darkblue", "red"), pt.bg = c("darkblue", NA),
           pt.cex = c(1, NA), legend = c("Wasserstand", "PEGELONLINE"),
           cex = cex_legend, bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1)
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1)
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1)
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1)
}

```

## Zusammenfassung {#flys-summary data-background="background.png" data-background-size="auto 800px"}

> - [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
interpoliert stationäre Wasserspiegellagen abschnittsweise mit jeweils einem
Bezugspegel
> - Die Auswahl des Bezugspegels und dessen relativer Abfluss kann starken
Einfluss auf die resultierende Wasserspiegellage haben
> - Ungleichwertige Abflüsse großer Nebengewässer können Differenzen von
mehreren Dezimetern zwischen mit 
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
abschnittsweise berechneten Wasserspiegellagen verursachen
> - Sprünge, bzw. Diskontinuitäten an Abschnittsgrenzen sind daher unvermeidbar

# hyd1d {#hyd1d data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#hyd1d-intro data-background="background.png" data-background-size="auto 800px"}

> - **hyd1d** ist als **R**-Paket programmiert und über
[CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht
> - **hyd1d** integriert Paket-eigene Pegeldaten aus der
[HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html),
aktuelle Pegeldaten von [PEGELONLINE](https://pegelonline.wsv.de), und
Wasserspiegellagen von [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
> - Pegel- und Wasserspiegeldaten werden so miteinander interpoliert, dass
resultierenden Wasserspiegellagen auch über lange Strecken keine
Diskontinuitäten aufweisen

## Methodik {#hyd1d-method data-background="background.png" data-background-size="auto 800px"}

1. Bestimmung der relevanten Pegel für den Berechnungsort, bzw. die
Berechnungsstrecke
2. Bestimmung der Wasserstände dieser Pegeln zum gewählten Zeitpunkt
3. Aufteilung der Berechnungsstrecke in Abschnitte, die von jeweils zwei Pegeln
eingerahmt werden
4. Abschnittsweise Bestimmung, welche
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen
die Wasserspiegellagen an den beiden Pegeln einrahmen
5. Abschnittsweise, entfernungsabhängige Interpolation zwischen den einrahmenden
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen

## 1. Streckenrelevante Pegel {#hyd1d-method-1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8),
         ylim = c(51, 58), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # berechnungsstrecke
    polygon(x = c(257, 262, 262, 257), y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
}
```

## 2. Wasserstände {#hyd1d-method-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8),
         ylim = c(51, 58), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "o",
           box.col = "white")
    box()
}
```

## 3. Aufteilung der Berechnungsstrecke {#hyd1d-method-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(243, 276.8),
         ylim = c(51, 58), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # stretch
    polygon(x = c(257, 262, 262, 257),
            y = c(50.8, 50.8, 58.2, 58.2),
            col = "grey95", border = NA)
    
    # sections
    for (i in 1:(nrow(gs) - 1)) {
        rect(gs$km_qps[i], 53, gs$km_qps[i + 1], 54, col = "lightblue",
             border = NA)
        text((gs$km_qps[i] + gs$km_qps[i + 1])/2, 53.5, i, font = 2)
        lines(rep(gs$km_qps[i], 2), c(53, 54), lwd = 2)
        lines(rep(gs$km_qps[i + 1], 2), c(53, 54), lwd = 2)
    }
    
    # landmarks
    abline(v = gs$km_qps, lty = 3, lwd = 0.5)
    text(gs$km_qps[1:2], c(52, 52), gs$gauging_station[1:2], cex = 1)
    text(gs$km_qps[3:4], c(57, 57), gs$gauging_station[3:4], cex = 1)
    
    # gauging data
    points(gs$km_qps, gs$wl, pch = 21, col = "darkblue", bg = "darkblue")
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "o",
           box.col = "white")
    box()
}
```

## 4. Einrahmende Wasserspiegellagen {#hyd1d-method-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-4}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    for (a_wl in flys3_water_levels){
        wldf_temp <- waterLevelFlys3(wldf, a_wl)
        lines(wldf_temp$station, wldf_temp$w, lty = 3, lwd = 0.2,
              col = "darkblue")
    }
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # FLYS
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i], col = "darkblue")
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "darkblue")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(a$w[i]), "a", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1)
    
    # legend
    legend("topright", pch = 21, col = "darkblue", pt.bg = "darkblue",
           pt.cex = 1, legend = "Wasserstand", cex = cex_legend, bty = "n")
}
```

## 5.1 Gewichtung an den Pegeln {#hyd1d-method-5-1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.52)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 4,
         font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 2,
         font = 2, col = "darkblue")
    
    # FLYS3
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(257.8, max(mq_0.5$w[i]), "0", pos = 2, font = 2)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    text(257.8, max(mq_0.75$w[i]), "1", pos = 2, font = 2, col = "red")
    
    # legend
    legend("topright", col = c("darkblue", "darkblue", "red", "black"),
           pch = c(21, NA, NA, NA), pt.bg = c("darkblue", NA, NA, NA),
           pt.cex = c(1, NA, NA, NA), lty = c(0, 0, 1, 1),
           legend = c("Wasserstand", "Gewicht", "obere FLYS3-WSL",
                      "untere FLYS3-WSL"), text.font = c(1, 2, 1, 1),
           text.col = c(1, "darkblue", 1, 1), cex = cex_legend, bty = "n")
}
```

## 5.2 Gewichtung entlang der Strecke {#hyd1d-method-5-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(-0.1, 1.1), xlab = "Flusskilometer (km)",
         ylab = "relatives Gewicht")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], -0.05, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 1.05, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 1.05, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # weighting
    lines(x = c(gs$km_qps[id][1], gs$km_qps[id][2]),
          y = c(gs$weight_up[id][1], gs$weight_do[id][2]))
    points(gs$km_qps[id][1], gs$weight_up[id][1], pch = 21, col = 1, bg = 1)
    points(gs$km_qps[id][2], gs$weight_do[id][2], pch = 21, col = 1, bg = 1)
    text(gs$km_qps[id][1], gs$weight_up[id][1], round(gs$weight_up[id][1], 2),
         pos = 2, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$weight_do[id][2], round(gs$weight_do[id][2], 2),
         pos = 4, font = 2, col = "darkblue")
}
```

## 5.3 Interpolation der Wasserspiegellage {#hyd1d-method-5-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # FLYS3
    i <- which(mq_0.5$station >= gs$km_qps[2] & mq_0.5$station <= gs$km_qps[3])
    lines(mq_0.5$station[i], mq_0.5$w[i])
    lines(mq_0.75$station[i], mq_0.75$w[i], col = "red")
    lines(wldf1$station[i], wldf1$w[i], col = "darkblue", lwd = 2)
    text(261.2, min(mq_0.5$w[i]), "0.5MQ", pos = 4, cex = 1)
    text(261.2, min(mq_0.75$w[i]), "0.75MQ", pos = 4, cex = 1, col = "red")
    
    # weighting
    text(gs$km_qps[id][1], gs$wl[id][1], round(gs$weight_up[id][1], 2), pos = 2,
         cex = 1, font = 2, col = "darkblue")
    text(gs$km_qps[id][2], gs$wl[id][2], round(gs$weight_do[id][2], 2), pos = 4,
         cex = 1, font = 2, col = "darkblue")
    
    # legend
    legend("topright",
           col = c("darkblue", "darkblue", "darkblue", "red", "black"),
           pch = c(21, NA, NA, NA, NA), pt.bg = c("darkblue", NA, NA, NA, NA),
           pt.cex = c(1, NA, NA, NA, NA), lty = c(0, 0, 1, 1, 1),
           lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS3-WSL",
                      "untere FLYS3-WSL"),
           text.col = c(1, "darkblue", 1, 1, 1), text.font = c(1, 2, 1, 1, 1),
           cex = cex_legend, bty = "n")
}
```

## 5.4 Interpolationen zusammengefasst {#hyd1d-method-5-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-method-5-4}
{
    par(cex = 1.2)
    plotShiny(wldf1, TRUE, TRUE, TRUE, xlim = c(xlim_min, xlim_max),
              ylim = c(ylim_min, ylim_max))
    
    # landmark
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 0.7, border = FALSE, col = "blue",
                 srt = 90)
    
    # legend
    legend("topright",
           col = c("darkblue", "darkblue", "darkblue", "red", "black"),
           pch = c(21, NA, NA, NA, NA), pt.bg = c("darkblue", NA, NA, NA, NA),
           pt.cex = c(1, NA, NA, NA, NA),
           lty = c(0, 0, 1, 1, 1), lwd = c(0, 0, 2, 1, 1),
           legend = c("Wasserstand", "Gewicht", "waterLevel", "obere FLYS3-WSL",
                      "untere FLYS3-WSL"),
           text.col = c(1, "darkblue", 1, 1, 1), cex = cex_legend, bty = "n")
    box()
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp1 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp1}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", lty = c(0, 1), lwd = c(0, 1), pch = c(21, NA),
           col = c("darkblue", "red"), pt.bg = c("darkblue", NA),
           pt.cex = c(1, NA), legend = c("Wasserstand", "PEGELONLINE"),
           cex = cex_legend, bty = "n")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp2}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    #polygon(x = c(wldf3$station, rev(wldf4$station)),
    #        y = c(wldf3$w, rev(wldf4$w)), col = "grey95", border = NA)
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lm
    lines(x = po$x, y = po$y, col = "red")
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", lty = c(0, 1, 1), lwd = c(0, 1, 1),
           pch = c(21, NA, NA), col = c("darkblue", "red", "darkblue"),
           pt.bg = c("darkblue", NA, NA), pt.cex = c(1, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS3"), cex = cex_legend,
           bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Vergleich der Wasserspiegellagen {#hyd1d-wsl-comp3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-wsl-comp3}
{
    par(cex = 1.2)
    plot(1, 1, type = "n", xlim = c(xlim_min, xlim_max),
         ylim = c(ylim_min, ylim_max), xlab = "Flusskilometer (km)",
         ylab = "H\u00f6he (m \u00fcber NHN (DHHN92))")
    
    # landmarks
    abline(v = gs$km_qps[2:3], lty = 3, lwd = 0.5)
    boxed.labels(gs$km_qps[2], 54, gs$gauging_station[2], cex = 1,
                 border = FALSE)
    boxed.labels(gs$km_qps[3], 55.5, gs$gauging_station[3], cex = 1,
                 border = FALSE)
    abline(v = 259.6, lty = 3, lwd = 0.5, col = "blue")
    boxed.labels(259.6, 55.5, "MULDE", cex = 1, border = FALSE, col = "blue")
    
    # lines
    lines(x = po$x, y = po$y, col = "red")
    lines(wldf2$station, wldf2$w, lty = 1, col = "darkblue")
    lines(wldf3$station, wldf3$w, lty = 2, col = "darkblue")
    lines(wldf4$station, wldf4$w, lty = 3, col = "darkblue")
    lines(wldf1$station, wldf1$w, lty = 1, col = "black", lwd = 2)
    
    # gauging data
    points(gs$km_qps[id], gs$wl[id], pch = 21, col = "darkblue",
           bg = "darkblue")
    
    # legend
    legend("topright", lty = c(0, 1, 1, 1), lwd = c(0, 1, 1, 2),
           pch = c(21, NA, NA, NA),
           col = c("darkblue", "red", "darkblue", "black"),
           pt.bg = c("darkblue", NA, NA, NA), pt.cex = c(1, NA, NA, NA),
           legend = c("Wasserstand", "PEGELONLINE", "FLYS3", "hyd1d"),
           cex = cex_legend, text.col = c("darkblue", "red", "darkblue",
                                          "black"), bty = "n")
    text(262.5, 54.7, "Bezugspegel", cex = 1, col = "darkblue")
    text(262, min(wldf2$w), "WITTENBERG", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf3$w), "ROSSLAU", pos = 4, cex = 1, col = "darkblue")
    text(262, min(wldf4$w), "DESSAU", pos = 4, cex = 1, col = "darkblue")
}
```

## Zusammenfassung {#hyd1d-summary data-background="background.png" data-background-size="auto 800px"}

> - **hyd1d** interpoliert stationäre Wasserspiegellagen von
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
abschnittsweise mit Hilfe der umliegenden Pegel
> - Die Interpolation wird mit **allen** für den Zeitpunkt und den
Gewässerabschnitt verfügbaren Pegeldaten durchgeführt
> - Ungleichwertige Abflüsse großer Nebengewässer werden durch die Pegel
abgebildet.
> - Sprünge, bzw. Diskontinuitäten werden durch das abschnittssweise
Aufhängen der resultierenden Wasserspiegellage an den Pegeln unmöglich

# Das R-Paket {#hyd1d-package data-background="background.png" data-background-size="auto 800px"}

## Installation {#hyd1d-install data-background="background.png" data-background-size="auto 800px"}

- **hyd1d** ist über CRAN verfügbar. Zur Installation und zum Laden reicht:

```{r hyd1d-install2, eval = FALSE, echo = TRUE}
install.packages("hyd1d")
library("hyd1d")
```

- Zur Installation der aktuellsten Entwicklungsversion von Github sind folgende
Befehle nötig:

```{r hyd1d-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_github("bafg-bund/hyd1d")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-1 data-background="background.png" data-background-size="auto 800px"}

> - Eine S4-Klasse auf Basis der S3-Klasse `data.frame`
> - In diesem wird intern die Wasserspiegellage abgelegt
> - 8 weitere Slots beinhalten alle weiteren berechnungs- und
darstellungsrelevanten Informationen

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-2 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-2}
str(wldf1, max.level = 2, vec.len = 3, width = 160, strict.width = "cut")
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-3 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-3}
head(as.data.frame(wldf1))
```

## S4-Klasse WaterLevelDataFrame {#hyd1d-s4-4 data-background="background.png" data-background-size="auto 800px"}

```{r hyd1d-s4-4}
str(wldf1@gauging_stations, max.level = 2, vec.len = 3, width = 160,
    strict.width = "cut")
```

## waterLevel...()-Funktionen {#hyd1d-waterLevel data-background="background.png" data-background-size="auto 800px"}

> - [waterLevelFlut1()](https://hyd1d.bafg.de/reference/waterLevelFlut1.html)
> - [waterLevelFlys3()](https://hyd1d.bafg.de/reference/waterLevelFlys3.html)
> - [waterLevelFlys3InterpolateX()](https://hyd1d.bafg.de/reference/waterLevelFlys3InterpolateX.html)
> - [waterLevelFlys3InterpolateY()](https://hyd1d.bafg.de/reference/waterLevelFlys3InterpolateY.html)
> - [waterLevel()](https://hyd1d.bafg.de/reference/waterLevel.html)
> - [waterLevelPegelonline()](https://hyd1d.bafg.de/reference/waterLevel.html)

## {#hyd1d-references data-background-iframe="https://hyd1d.bafg.de/reference/index.html"}

# hydflood {#hydflood data-background="background.png" data-background-size="auto 800px"}

## Einleitung {#hydflood-intro data-background="background.png" data-background-size="auto 800px"}

> - **hydflood** ist als **R**-Paket programmiert und über
[CRAN](https://cran.r-project.org) unter der
[GPL2](https://www.gnu.org/licenses/gpl-2.0) veröffentlicht
> - **hydflood** dient der Berechnung von Überflutungsflächen und -dauern,
äquivalent zum INFORM-Modul Flut 3.
> - Wasserspiegellagen, die mittels **hyd1d** berechnet wurden, werden über
Querprofilflächen in die Aue extrapoliert und mit digitalen Geländemodellen
(DGM's) verglichen

## Datengrundlagen {#hydflood-data data-background="background.png" data-background-size="auto 800px"}

> - Querprofilspuren aus den SOBEK-Modellen für
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html),
umgerechnet zu Querprofilflächen (`qpf`)
> - Wasserspiegellagen von **hyd1d**
> - Digitale Geländemodelle (`dgm`)

## {#hydflood-data-csa1 data-background="screenshot_hydflood_crosssections.png" data-background-size="auto 800px"}

## {#hydflood-data-csa2 data-background="screenshot_hydflood_crosssectionareas.png" data-background-size="auto 800px"}

## {#hydflood-data-csa3 data-background="screenshot_hydflood_crosssectionareas_cs.png" data-background-size="auto 800px"}

## {#hydflood-data-dem data-background="screenshot_hydflood_dem.png" data-background-size="auto 800px"}

## flood3()-Funktion {#hydflood-algorythm data-background="background.png" data-background-size="auto 800px"}

> - Berechnung der Wasserspiegellage
> - Übertrag der Wasserspiegellage über das Join-Feld `station_int` auf die
Querprofilflächen (`qpf`)
> - `ufd[qpf > dgm] = ufd[qpf > dgm] + 1`
> - gegebenenfalls Wiederholung über eine Sequenz von Zeitschritten

## 21.12.2016 {#hydflood-algorythm1 data-background="screenshot_hydflood_20161221.png" data-background-size="auto 800px"}

## {#hydflood-algorythm2 data-background="screenshot_hydflood_20161221_video.png" data-background-size="auto 800px"}

## {#hydflood-video data-background-video="flood3-2fps-dessau.mp4"}

## 2002 {#hydflood-algorythm3 data-background="screenshot_hydflood_2002.png" data-background-size="auto 800px"}

## 2016 {#hydflood-algorythm4 data-background="screenshot_hydflood_2016.png" data-background-size="auto 800px"}

## Vergleich von Überflutungsdauern {#hydflood-comp data-background="background.png" data-background-size="auto 800px"}

- Es fehlt ein Vergleich zwischen den Überflutungsdauern nach **flood3** und
einem instationären 2D- oder 3D-Hydraulik-Modell und realen Messdaten

## Zusammenfassung {#hydflood-summary data-background="background.png" data-background-size="auto 800px"}

> - **hydflood** verwendet interpolierte Wasserspiegellagen von **hyd1d**, um
mittels der Funktion `flood3()` Überflutungsflächen und -dauern zu berechnen
> - Vorteile:
>     * wenige, bereits vorhandene Eingangsdatensätze (DGM, Querprofilspuren, Pegeldaten)
>     * hohe räumliche und zeitliche Auflösung
>     * kachelweise parallelisierbare, schnelle und großflächige Berechnung
> - Nachteil:
>     * kein physikalisches Modell, auch Flächen ohne Zufluss werden überflutet

# Das R-Paket {#hydflood-package data-background="background.png" data-background-size="auto 800px"}

## Installation {#hydflood-install data-background="background.png" data-background-size="auto 800px"}

- **hydflood** ist über CRAN verfügbar. Zur Installation und zum Laden reicht:

```{r hydflood-install2, eval = FALSE, echo = TRUE}
install.packages("hydflood")
library("hydflood")
```

- Zur Installation der aktuellsten Entwicklungsversion von Github sind folgende
Befehle nötig:

```{r hydflood-install1, eval = FALSE, echo = TRUE}
install.packages("devtools")
library("devtools")
install_github("bafg-bund/hydflood")
```

## hydSpatRaster {#hydflood-s1 data-background="background.png" data-background-size="auto 800px"}

> - Ein Objekt auf Basis der S4-Klasse `SpatRaster`
> - Beinhaltet Layer des digitalen Geländemodells (`dgm`) und der
Querprofilflächen (`qpf`)
> - eigene Datensätze sind verwendbar, ansonsten stehen Paket-eigene
Querprofilfächen und downloadbare digitale Geländemodelle (`dgm`) zur Verfügung
> - für diese automatisierte Erstellung eines `SpatRaster` müssen nur die
Ausdehnung (`ext`) und das Koordinatensystem (`crs`) angegeben werden

## hydSpatRaster {#hydflood-s2 data-background="background.png" data-background-size="auto 800px"}

- Initialisierung des `hydSpatRaster` mit Nutzer-eigenen Datensätzen
```{r hydflood-hydSpatRaster1, eval = FALSE, echo = TRUE}
x <- hydSpatRaster(filename_dem = "data-raw/raster.dem.tif",
                   filename_csa = "data-raw/raster.csa.tif")
```

- mit `extent(x)` und `CRS(x)` `SpatRaster` initialisieren und Daten herunterladen 
```{r hydflood-hydSpatRaster2, eval = FALSE, echo = TRUE}
ext <- extent(x)
crs <- CRS(x)
x <- hydSpatRaster(ext = ext, crs = crs)
```

## hydSpatRaster {#hydflood-s3 data-background="background.png" data-background-size="auto 800px"}

```{r hydflood-hydSpatRaster-strprep, eval = TRUE, echo = FALSE}
hf3 <- Sys.getenv("hydflood")

# mit eigenen Datensätzen
x <- hydSpatRaster(filename_dem = paste0(hf3, "/data-raw/raster.dem.tif"),
                   filename_csa = paste0(hf3, "/data-raw/raster.dem.tif"))
```

```{r hydflood-hydSpatRaster-str}
str(x, max.level = 2, vec.len = 3, width = 160, strict.width = "cut")
```

## flood3() {#hydflood-flood3 data-background="background.png" data-background-size="auto 800px"}

```{r hydflood-flood, eval = FALSE, echo = TRUE}
# Initialisierung von x mit eigenen Datensätzen
x <- hydSpatRaster(filename_dem = "data-raw/raster.dem.tif",
                   filename_csa = "data-raw/raster.csa.tif")

# Sequenz des Berechnungszeitraums
seq <- seq.Date(from = as.Date("2017-01-01"),
                to = as.Date("2017-12-31"),
                by = "day")

# Berechnung der Überflutungsdauer
ufd <- flood3(x = x, seq = seq)
```

## {#hydflood-references data-background-iframe="https://hydflood.bafg.de/reference/index.html"}

# Produkte {#products data-background="background.png" data-background-size="auto 800px"}

## {#product-waterlevels data-background="screenshot_hyd1d_products.png"}

## {#product-shiny-waterlevel data-background-iframe="https://shiny.bafg.de/waterlevel/"}

## {#product-shiny-waterlevelpegelonline data-background-iframe="https://shiny.bafg.de/waterlevelpegelonline/"}

## {#product-raster data-background="screenshot_hydflood_products.png"}

## {#product-shiny-flood3 data-background-iframe="http://r.bafg.de/shiny/WeberA/07-flood3/"}

## {#product-shiny-flood3-wms data-background-iframe="https://shiny.bafg.de/flood3wms/"}

# Veröffentlichung {#publication data-background="background.png" data-background-size="auto 800px"}

## hyd1d {#hyd1d-publication data-background="background.png" data-background-size="auto 800px"}

> - OpenSource-Package auf [CRAN](https://cran.r-project.org/package=hyd1d)
> - Dokumentationswebseite
> - beinhaltet eine Veröffentlichung von
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)-Wasserspiegellagen
und [HyDaBa](http://www.bafg.de/DE/08_Ref/M1/03_Pegelwesen/HYDABA/hydaba_node.html)-Pegeldaten
> - vorberechnete 1d-Wasserspiegellagen für Rhein und Elbe vom 01.01.1990 bis gestern
> - Shiny-Services [waterLevel()](https://shiny.bafg.de/waterlevel/)
und [waterLevelPegelonline()](https://shiny.bafg.de/waterlevelpegelonline/)
> - Einbettung der Shiny-Services in
[FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html) 3.3

## hydflood {#hydflood-publication data-background="background.png" data-background-size="auto 800px"}

> - OpenSource-Package auf [CRAN](https://cran.r-project.org/package=hydflood)
> - Dokumentationswebseite
> - beinhaltet eine (Wieder-)Veröffentlichung der
[DGM-W](https://www.govdata.de/daten/-/details/1c669080-c804-11e4-8731-1681e6b88ec1bkg)'s
und der Querprofilflächen
> - jährliche Überflutungsdauerraster von 1990 bis 2019
> - langjährig aggregierte Überflutungsdauerraster
> - WMS-Dienste der jährlichen und aggregierten Überflutungsdauerraster
> - Shiny-Services [flood3daily](https://shiny.bafg.de/flood3daily/)
und [flood3wms](https://shiny.bafg.de/flood3wms/)
> - Einbettung der WMS-Dienste in [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
3.3
> - Einbettung der Shiny-Services in [FLYS3](https://www.bafg.de/DE/08_Ref/M2/03_Fliessgewmod/01_FLYS/flys_node.html)
3.3

## {#publication-ems data-background-iframe="https://www.journals.elsevier.com/environmental-modelling-and-software"}

# {#flood3-result data-background-iframe="http://r.bafg.de/shiny/WeberA/07-flood3/?_state_id_=530c656e3abaa905"}

# Danke {#thanks data-background="background.png" data-background-size="auto 800px"}

## Danke {#thanks-list data-background="background.png" data-background-size="auto 800px"}

> - Z2: Klaus Reuter, Kai Schramm
> - M1: Wilfried Wiechmann und das Team der Datenstelle M1
> - M2: Wolfgang Stürmer, Markus Promny, Bastian Klein
> - M3: Marcel Reiss
> - M4: Torsten Fay, Thomas Recknagel
> - M5: Lars Schumann
> - U3: Peter Horchler, Elmar Fuchs, Uwe Schröder

# Fragen? {#questions data-background="background.png" data-background-size="auto 800px"}

# Vielen Dank für Ihre Aufmerksamkeit {#thanks-to-you data-background="background.png" data-background-size="auto 800px"}

# {#contact data-background="contact.png"}

# {#lenzen data-background-video="flood3-2fps-lenzen.mp4"}
